/**
 * sainternet.xyz - resources/javascript/serviceworker.min.js
 * Copyright 2023 saint-lascivious (Hayden Pearce). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

/**
 * Some helper variables used later are defined here.
 */
const baseDomain = 'https://sainternet.xyz';
const shortName = 'sainternet';
const cacheVersionPrefix = '_v';
const cacheVersion = '59';
const cacheName = `${shortName}${cacheVersionPrefix}${cacheVersion}`;


/**
 * Critical cache resource arrays are listed here.
 */
const htmlCritical = [
  `${baseDomain}/`,
  `${baseDomain}/265.html`,
  `${baseDomain}/404.html`,
  `${baseDomain}/connecttosainternet.html`,
  `${baseDomain}/debug.html`,
  `${baseDomain}/filtereddns.html`,
  `${baseDomain}/frequentlyaskedquestions.html`,
  `${baseDomain}/index.html`,
  `${baseDomain}/newsandupdates.html`,
  `${baseDomain}/pokedexoverdns.html`,
  `${baseDomain}/portsandprotocols.html`,
  `${baseDomain}/projects.html`,
  `${baseDomain}/reportaproblem.html`,
  `${baseDomain}/technologies.html`,
  `${baseDomain}/testsainternet.html`,
];

const cssCritical = [
  `${baseDomain}/resources/fontawesome-free-6.3.0-web/css/brands.min.css`,
  `${baseDomain}/resources/fontawesome-free-6.3.0-web/css/fontawesome.min.css`,
  `${baseDomain}/resources/fontawesome-free-6.3.0-web/css/solid.min.css`,
  `${baseDomain}/resources/google/css/materialicons.min.css`,
  `${baseDomain}/resources/google/css/roboto.min.css`,
  `${baseDomain}/resources/stylesheets/button_home.min.css`,
  `${baseDomain}/resources/stylesheets/datetime.min.css`,
  `${baseDomain}/resources/stylesheets/img.min.css`,
  `${baseDomain}/resources/stylesheets/pre.min.css`,
  `${baseDomain}/resources/stylesheets/ribbons.min.css`,
  `${baseDomain}/resources/stylesheets/sainternet.min.css`,
  `${baseDomain}/resources/stylesheets/table.min.css`,
];

const jsCritical = [
  `${baseDomain}/resources/javascript/console_wrapper.min.js`,
  `${baseDomain}/resources/javascript/debug.min.js`,
  `${baseDomain}/resources/javascript/load_fonts.min.js`,
  `${baseDomain}/resources/javascript/material.min.js`,
  `${baseDomain}/resources/javascript/random_phrase.min.js`,
  `${baseDomain}/resources/javascript/tag_manager.min.js`,
  `${baseDomain}/resources/javascript/toggle_drawer.min.js`,
  `${baseDomain}/sainternet.min.js`,
];

/**
 * Critical cache items.
 */
const cacheCritical = [
  ...htmlCritical,
  ...cssCritical,
  ...jsCritical,
];

/**
 * Logs a message to the console, with optional date and time information, if
 * the DEBUG flag is set to true.
 *
 * Checks if console exists as an object, and console.logType (default 'log')
 * exists as a function.
 *
 * Safe to use in environments where console or logType are undefined.
 *
 * @function
 * @name consoleWrapper
 * @param {string} message - The message to be logged.
 * @param {string} [logType='log'] - The type of console method to use (log,
 * error, warn, etc.).
 * @param {boolean} [includeDateTime=false] - Whether to include the current
 * date and time in the log message.
 */
function consoleWrapper(message, logType = 'log', includeDateTime = false) {
  if (self.DEBUG && includeDateTime) {
    message = `${new Date().toLocaleString()} - ${message}`;
  }
  if (self.DEBUG && typeof console === 'object' && typeof console[logType] === 'function') {
    console[logType](message);
  }
}

/**
 * Logs a message to the console.
 *
 * Checks if console exists as an object, and console.logType (default 'log')
 * exists as a function.
 *
 * Safe to use in environments where console or logType are undefined.
 *
 * @function
 * @name consoleWrapperSimple
 * @param {string} message - The message to be logged.
 * @param {string} [logType='log'] - The type of console method to use (log,
 * error, warn, etc.).
 */
function consoleWrapperSimple(message, logType = 'log') {
  if (typeof console === 'object' && typeof console[logType] === 'function') {
    console[logType](message);
  }
}

/**
 * Fetches and caches a list of URLs using the given cache name.
 *
 * @function
 * @name cacheUrls
 *
 * @param {string[]} urls - An array of URLs to fetch and cache.
 * @param {string} cacheName - The name of the cache to use.
 * @return {Promise<void>} - A promise that resolves when all the URLs have
 * been fetched and cached, or rejects if any of them fail.
 */
function cacheUrls(urls) {
  return caches.open(cacheName).then(function(cache) {
    return Promise.all(
      urls.map(function(url) {
        return fetch(url).then(function(response) {
          if (!response.ok) {
            consoleWrapper(`[Service Worker] Failed to cache ${url}: ${response.status}`, 'error');
          }
          return cache.put(url, response);
        }).then(function() {
          consoleWrapper(`[Service Worker] Cached ${url}: ${response.status}`);
        });
      })
    );
  });
}

/**
 * Event listener for the 'install' event. This listener is triggered when the
 * service worker is installed.
 *
 * @param {ExtendableEvent} event - The event object for the 'install' event.
 */
self.addEventListener('install', function(event) {
  consoleWrapper(`[Service Worker] Event: install ${shortName}`);
  try {
    event.waitUntil(
      cacheUrls(cacheCritical).then(function() {
        consoleWrapper(`[Service Worker] Finished caching critical assets`);
        return self.skipWaiting();
      }).catch(function(error) {
        consoleWrapper(`[Service Worker] Error during cache fetch: ${error}`, 'error');
      })
    );
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during install event: ${error}`, 'error');
  }
});

/**
 * Event listener for the 'activate' event of the service worker.
 *
 * @param {ExtendableEvent} event - The event object for the 'activate' event.
 */
self.addEventListener('activate', function(event) {
  consoleWrapper(`[Service Worker] Event: activate ${shortName}`);
  try {
    if (self.registration.navigationPreload) {
      consoleWrapper(`[Service Worker] Enabling service worker navigation preload`);
      event.waitUntil(self.registration.navigationPreload.enable());
    }
    if (self.clients && clients.claim) {
      consoleWrapper(`[Service Worker] Claiming available clients`);
      clients.claim();
    }
    event.waitUntil(
      caches.keys().then(function(keyList) {
        const cacheNamePrefix = `${shortName}-`;
        const cacheWhitelist = [cacheName];
        keyList.forEach(function(key) {
          if (key.startsWith(cacheNamePrefix) && key !== cacheName) {
            consoleWrapper(`[Service Worker] Deleting orphaned cache: ${key}`);
            cacheWhitelist.push(key);
          }
        });
        return Promise.all(keyList.map(function(key) {
          if (cacheWhitelist.indexOf(key) === -1) {
            return caches.delete(key);
          }
        }));
      })
    );
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during activate event: ${error}`, 'error');
  }
});

/**
 * Event listener for the 'fetch' event. This listener is triggered when the
 * service worker intercepts a request from the client.
 *
 * Cache first fetch policy with additional opportunistic origin domain based
 * caching. Successful GETs are cached when the origin domain is the base
 * domain or known to the cacheOriginDomains array.
 *
 * @param {FetchEvent} event - The event object for the 'fetch' event.
 */
self.addEventListener('fetch', function(event) {
  try {
    if (event.request.method !== 'GET') {
      consoleWrapper(`[Service Worker] Not handling request ${event.request.url} with method ${event.request.method}`);
      return;
    }
    const cacheOriginDomains = [
      baseDomain,
    ];
    const requestUrl = new URL(event.request.url);
    if (!cacheOriginDomains.some((domain) => requestUrl.origin.startsWith(domain))) {
      return fetch(event.request);
    }
    event.respondWith(
      caches.match(event.request).then(function(response) {
        if (response) {
          consoleWrapper(`[Service Worker] Returning response from cache: ${event.request.url}`);
          return response;
        }
        consoleWrapper(`[Service Worker] Fetching from network: ${event.request.url}`);
        return fetch(event.request).then(function(response) {
          if (!response || response.status !== 200 || response.type !== 'basic') {
            consoleWrapper(`[Service Worker] Response not eligible for caching: ${event.request.url}`);
            return response;
          }
          const fetchResponse = response.clone();
          caches.open(cacheName).then(function(cache) {
            consoleWrapper(`[Service Worker] Adding response to cache: ${event.request.url}`);
            cache.put(event.request, fetchResponse);
          });
          consoleWrapper(`[Service Worker] Returning response from network: ${event.request.url}`);
          return response;
        });
      })
    );
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during fetch event: ${error}`, 'error');
  }
});

/**
 * Event listener for the 'onupdatefound' event of the service worker.
 * This event is fired when a new version of the service worker has been
 * found.
 *
 * @event ServiceWorkerGlobalScope#onupdatefound
 * @param {Event} event - The event object for the 'onupdatefound' event.
 */
self.addEventListener('onupdatefound', function(event) {
  consoleWrapper('[Service Worker] Service worker update found');
});

/**
 * Event listener for the 'controllerchange' event of the service worker.
 * This event is fired when the service worker controlling the page has
 * changed.
 *
 * @event ServiceWorkerGlobalScope#controllerchange
 * @param {Event} event - The event object for the 'controllerchange' event.
 */
self.addEventListener('controllerchange', function(event) {
  consoleWrapper('[Service Worker] Service worker controller changed');
});

/**
 * Event listener for the updatefound event fired by the service worker
 * registration object. Logs the service worker update life cycle.
 *
 * Features an object literal to map the state values of the service worker
 * update life cycle to their corresponding consoleWrapper log messages.
 *
 * @param {ExtendableEvent} event - The event object for the 'updatefound'
 * event.
 */
self.addEventListener('updatefound', (event) => {
  const serviceWorkerStateToMessage = {
    installing: 'New service worker version installing',
    installed: 'New service worker version installed',
    activating: 'New service worker version activating',
    activated: 'New service worker version activated',
    redundant: 'New service worker version redundant',
  };
  consoleWrapper('[Service Worker] Event: updatefound');
  const newServiceWorker = event.target.installing;
  newServiceWorker.addEventListener('statechange', () => {
    consoleWrapper(`[Service Worker] ${serviceWorkerStateToMessage[newServiceWorker.state]}`);
  });
});

/**
 * Listens for messages sent from the client, takes appropriate action.
 *
 * Current events are 'debug', 'info', and 'ping'.
 *
 * @function
 * @param {MessageEvent} event - The event object containing the message data.
 * @returns {void}
 */
self.addEventListener('message', function(event) {
  if (event.data.type === 'debug') {
    const debugValue = event.data.value;
    self.DEBUG = debugValue;
    consoleWrapperSimple(`[Service Worker] DEBUG: ${debugValue}`);
  } else if (event.data === 'info') {
    consoleWrapperSimple(`[Service Worker] Name: ${shortName}`);
    consoleWrapperSimple(`[Service Worker] Cache version: ${cacheVersion}`);
    consoleWrapperSimple(`[Service Worker] Cache name: ${cacheName}`);
    consoleWrapperSimple(`[Service Worker] Scope: ${baseDomain}`);
    consoleWrapperSimple(`[Service Worker] Service worker: ${baseDomain}/serviceworker.min.js`);
  } else if (event.data === 'ping') {
    consoleWrapperSimple('[Service Worker] Pong');
  }
});
