/**
 * sainternet.xyz - resources/javascript/serviceworker.min.js
 * Copyright 2023 saint-lascivious (Hayden Pearce). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

/**
 * Some helper variables used later are defined here.
 */
const appDomain = 'sainternet';
const appProto = 'https://';
const appTld = '.xyz';
const appVersion = '_v1.4';
const basePath = `${appProto}${appDomain}${appTld}`;
const resourcePath = `${basePath}/resources`;
const cssPath = `${resourcePath}/stylesheets`;
const fontawesomePath = `${resourcePath}/fontawesome-free-6.4.0-web`;
const googlePath = `${resourcePath}/google`;
const iconPath = `${resourcePath}/icons`;
const imgPath = `${resourcePath}/images`;
const jsPath = `${resourcePath}/javascript`;
const cacheName = `${appDomain}${appVersion}`;

/**
 * Cache resource arrays are listed here.
 */
const cssUrls = [
  `${fontawesomePath}/css/brands.min.css`,
  `${fontawesomePath}/css/fontawesome.min.css`,
  `${googlePath}/css/materialicons.min.css`,
  `${googlePath}/css/roboto.min.css`,
  `${googlePath}/css/robotomono.min.css`,
  `${cssPath}/button_home.min.css`,
  `${cssPath}/datetime.min.css`,
  `${cssPath}/img.min.css`,
  `${cssPath}/material.amber-red.min.css`,
  `${cssPath}/material.blue_grey-red.min.css`,
  `${cssPath}/material.blue-red.min.css`,
  `${cssPath}/material.brown-red.min.css`,
  `${cssPath}/material.cyan-red.min.css`,
  `${cssPath}/material.deep_orange-red.min.css`,
  `${cssPath}/material.deep_purple-red.min.css`,
  `${cssPath}/material.green-red.min.css`,
  `${cssPath}/material.grey-red.min.css`,
  `${cssPath}/material.indigo-red.min.css`,
  `${cssPath}/material.light_blue-red.min.css`,
  `${cssPath}/material.light_green-red.min.css`,
  `${cssPath}/material.lime-red.min.css`,
  `${cssPath}/material.orange-red.min.css`,
  `${cssPath}/material.pink-red.min.css`,
  // unassigned, incorrect theme colour behaviour observed in dark mode
  // `${cssPath}/material.purple-red.min.css`,
  `${cssPath}/material.red-blue.min.css`,
  `${cssPath}/material.teal-red.min.css`,
  `${cssPath}/material.yellow-red.min.css`,
  `${cssPath}/mono.min.css`,
  `${cssPath}/party-time.min.css`,
  `${cssPath}/ribbons.min.css`,
  `${cssPath}/sainternet.min.css`,
  `${cssPath}/shadow-boxing.min.css`,
  `${cssPath}/table.min.css`,
];

const fontUrls = [
  `${fontawesomePath}/webfonts/fa-brands-400.woff2`,
  `${googlePath}/webfonts/materialicons/v140/Material-Icons.woff2`,
  `${googlePath}/webfonts/robotomono/v22/RobotoMono-BoldItalic.woff2`,
  `${googlePath}/webfonts/robotomono/v22/RobotoMono-Bold.woff2`,
  `${googlePath}/webfonts/robotomono/v22/RobotoMono-Italic.woff2`,
  `${googlePath}/webfonts/robotomono/v22/RobotoMono-Regular.woff2`,
  `${googlePath}/webfonts/roboto/v30/Roboto-Black.woff2`,
  `${googlePath}/webfonts/roboto/v30/Roboto-Bold.woff2`,
  `${googlePath}/webfonts/roboto/v30/Roboto-Italic.woff2`,
  `${googlePath}/webfonts/roboto/v30/Roboto-Medium.woff2`,
  `${googlePath}/webfonts/roboto/v30/Roboto-Regular.woff2`,
];

const htmlUrls = [
  `${basePath}/265.html`,
  `${basePath}/404.html`,
  `${basePath}/archive.html`,
  `${basePath}/connecttosainternet.html`,
  `${basePath}/debug.html`,
  `${basePath}/devdiary.html`,
  `${basePath}/filtereddns.html`,
  `${basePath}/frequentlyaskedquestions.html`,
  `${basePath}/index.html`,
  `${basePath}/newsandupdates.html`,
  `${basePath}/pokedexoverdns.html`,
  `${basePath}/portsandprotocols.html`,
  `${basePath}/projects.html`,
  `${basePath}/reportaproblem.html`,
  `${basePath}/technologies.html`,
  `${basePath}/testsainternet.html`,
];

const imageUrls = [
  `${imgPath}/pihole_percent-day.webp`,
  `${imgPath}/pihole_percent-week.webp`,
  `${imgPath}/pihole_percent-month.webp`,
  `${imgPath}/pihole_percent-year.webp`,
  `${imgPath}/farquaad.webp`,
  `${imgPath}/luxio.webp`,
  `${imgPath}/luxio-shiny.webp`,
  `${imgPath}/terminal.webp`,
  `${imgPath}/wurmple.webp`,
  `${imgPath}/wurmple-shiny.webp`,
];

const iconUrls = [
  `${basePath}/favicon.ico`,
  `${iconPath}/favicon/favicon.ico`,
  `${iconPath}/favicon/favicon-16x16.png`,
  `${iconPath}/favicon/favicon-24x24.png`,
  `${iconPath}/favicon/favicon-32x32.png`,
  `${iconPath}/android-chrome-48x48.png`,
  `${iconPath}/favicon/favicon-64x64.png`,
  `${iconPath}/android-chrome-72x72.png`,
  `${iconPath}/android-chrome-96x96.png`,
  `${iconPath}/android-chrome-128x128.png`,
  `${iconPath}/android-chrome-192x192.png`,
  `${iconPath}/android-chrome-384x384.png`,
  `${iconPath}/android-chrome-512x512.png`,
  `${iconPath}/apple-touch-icon-180x180.png`,
  `${iconPath}/browserconfig.xml`,
  `${iconPath}/mstile-144x144.png`,
  `${iconPath}/mstile-150x150.png`,
  `${iconPath}/safari-pinned-tab.svg`,
];

const jsUrls = [
  `${jsPath}/console_wrapper.min.js`,
  `${jsPath}/debug.min.js`,
  `${jsPath}/load_fonts.min.js`,
  `${jsPath}/load_mono_fonts.min.js`,
  `${jsPath}/material.min.js`,
  `${jsPath}/random_url.min.js`,
  `${jsPath}/tag_manager.min.js`,
  `${jsPath}/toggle_drawer.min.js`,
  `${basePath}/sainternet.min.js`,
  `${basePath}/serviceworker.min.js`,
];

const screenshotUrls = [
  `${resourcePath}/screenshots/landscape/debug.webp`,
  `${resourcePath}/screenshots/landscape/filtereddns.webp`,
  `${resourcePath}/screenshots/landscape/home.webp`,
  `${resourcePath}/screenshots/landscape/newsandupdates.webp`,
  `${resourcePath}/screenshots/landscape/pokedexoverdns.webp`,
  `${resourcePath}/screenshots/landscape/popularprojects.webp`,
  `${resourcePath}/screenshots/portrait/debug.webp`,
  `${resourcePath}/screenshots/portrait/filtereddns.webp`,
  `${resourcePath}/screenshots/portrait/home.webp`,
  `${resourcePath}/screenshots/portrait/newsandupdates.webp`,
  `${resourcePath}/screenshots/portrait/pokedexoverdns.webp`,
  `${resourcePath}/screenshots/portrait/popularprojects.webp`,
];

/**
 * Critical cache item array, items in this array will be fetched with a
 * network first policy.
 */
const cacheCritical = [
  ...htmlUrls,
  ...cssUrls,
  ...jsUrls,
];

/**
 * Installation cache item array, everything required to function offline.
 */
const cacheOnInstall = [
  ...htmlUrls,
  ...iconUrls,
  ...imageUrls,
  ...cssUrls,
  ...jsUrls,
  ...fontUrls,
  ...screenshotUrls,
];

/**
 * Domains in the following array are considered valid cache origins.
 */
const originDomains = [
  basePath,
];

/**
 * Logs a message to the console, with optional date and time information, if
 * the CONSOLE_LOGGING flag is set to true.
 *
 * Checks if console exists as an object, and console.logType (default 'log')
 * exists as a function.
 *
 * Safe to use in environments where console or logType are undefined.
 *
 * @function
 * @name consoleWrapper
 * @param {string} message - The message to be logged.
 * @param {string} [logType='log'] - The type of console method to use (log,
 * error, warn, etc.).
 * @param {boolean} [includeDateTime=false] - Whether to include the current
 * date and time in the log message.
 */
function consoleWrapper(message, logType = 'log', includeDateTime = false) {
  if (includeDateTime) {
    message = `${new Date().toLocaleString()} - ${message}`;
  }
  if (self.CONSOLE_LOGGING && typeof console === 'object' && typeof console[logType] === 'function') {
    console[logType](message);
  }
}

/**
 * Logs a message to the console.
 *
 * Checks if console exists as an object, and console.logType (default 'log')
 * exists as a function.
 *
 * Safe to use in environments where console or logType are undefined.
 *
 * @function
 * @name consoleWrapperSimple
 * @param {string} message - The message to be logged.
 * @param {string} [logType='log'] - The type of console method to use (log,
 * error, warn, etc.).
 */
function consoleWrapperSimple(message, logType = 'log') {
  if (typeof console === 'object' && typeof console[logType] === 'function') {
    console[logType](message);
  }
}

/**
 * Fetches and caches an array of URLs using the given cache name.
 *
 * @function
 * @name fetchCacheUrlArray
 *
 * @param {string} cacheName - The name of the cache to use.
 * @param {string} cacheUrlArray - An array of URLs to fetch and cache.
 * @return {Promise<void>} - A promise that resolves when all the URLs have
 * been fetched and cached, or rejects if any of them fail.
 */
function fetchCacheUrlArray(cacheName, cacheUrlArray) {
  consoleWrapper(`[Service Worker] Opening ${cacheName}`);
  return caches.open(cacheName).then((cache) => {
    return Promise.all(
      cacheUrlArray.map((url) => fetch(url).then((response) => {
        if (response.ok) {
          cache.put(url, response.clone());
          consoleWrapper(`[Service Worker] Cached ${url}: ${response.status}`);
          return response;
        }
        consoleWrapper(`[Service Worker] Failed to cache ${url}: ${response.status}`, 'error');
      }).catch((error) => {
        consoleWrapper(`[Service Worker] Fetch failed for cache: ${cacheName}`, 'error');
      }))
    );
  });
}

/**
 * Simple custom sleep implementation, since apparently 'sleep()' just plain
 * isn't a thing in JavaScript.
 *
 * Wait for a duration. If a duration is not specified, wait for a random
 * duration between 100 and 2500 (in multiples of 50), in the simplest fashion
 * I could come up with to do so.
 *
 * Personally I kind of dislike this, but actions faking a 'working' state is
 * not exactly a new concept.
 *
 * @function
 * @name sleepFor
 * @param {number} [sleepDuration] - Time to sleep in millis, random if null.
 */
function sleepFor(sleepDuration) {
  if (!sleepDuration) {
    sleepDuration = Math.floor(Math.random() * 49) * 50 + 100;
  }
  const now = Date.now();
  while (Date.now() < now + sleepDuration) {
  }
}

/**
 * Event listener for service worker 'activate' events.
 *
 * @param {ExtendableEvent} event - The event object for the 'activate' event.
 */
self.addEventListener('activate', function(event) {
  consoleWrapper(`[Service Worker] Event: activate ${appDomain}`);
  try {
    if (self.clients && clients.claim) {
      consoleWrapper(`[Service Worker] Claiming available clients`);
      clients.claim();
    }
    event.waitUntil(
      caches.keys().then(function(keyList) {
        const cacheWhitelist = keyList.filter(function(key) {
          return key.indexOf(appDomain);
        });
        cacheWhitelist.push(cacheName);
        return Promise.all(keyList.map(function(key, i) {
          if (cacheWhitelist.indexOf(key) === -1) {
            console.log(`[Service Worker] Deleting orphaned cache: ${keyList[i]}`);
            return caches.delete(keyList[i]);
          }
        }));
      })
    );
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during activate event: ${error}`, 'error');
  }
});

/**
 * Event listener for service worker 'install' events.
 *
 * @param {ExtendableEvent} event - The event object for the 'install' event.
 */
self.addEventListener('install', function(event) {
  consoleWrapper(`[Service Worker] Event: install ${appDomain}`);
  try {
    event.waitUntil(
      fetchCacheUrlArray(cacheName, cacheOnInstall).then(function() {
        consoleWrapper(`[Service Worker] Finished caching critical assets`);
        return self.skipWaiting();
      }).catch(function(error) {
        consoleWrapper(`[Service Worker] Error during cache fetch: ${error}`, 'error');
      })
    );
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during install event: ${error}`, 'error');
  }
});

/**
 * Event listener for the service worker 'fetch' events.
 *
 * If the requested resource is in the 'cacheCritical' array, this event
 * listener uses a network first strategy, fetching from the network or
 * falling back to cache.
 *
 * If the requested resource is not in the 'cacheCritical' array, this event
 * listener uses a cache first strategy, returning the cached response if it
 * exists and fetching from the network if it doesn't.
 *
 * Only handles requests with method type 'GET'.
 *
 * Responses are cached if they are HTTP 200 responses with a 'basic' type.
 *
 * Requests for resources with origins outside of the 'originDomains'
 * array are not cached.
 *
 * @param {FetchEvent} event - The event object for the 'fetch' event.
 */
self.addEventListener('fetch', function(event) {
  try {
    if (event.request.method !== 'GET') {
      consoleWrapper(`[Service Worker] Not handling request ${event.request.url} with method ${event.request.method}`);
      return;
    }
    const requestUrl = new URL(event.request.url);
    if (cacheCritical.includes(requestUrl.pathname) && originDomains.some((domain) => requestUrl.origin.startsWith(domain))) {
      event.respondWith(
        fetch(event.request)
          .then(function(response) {
            if (!response || response.status !== 200 || response.type !== 'basic') {
              consoleWrapper(`[Service Worker] Response not eligible for caching: ${event.request.url}`);
              return response;
            }
            if (originDomains.some((domain) => new URL(response.url).origin.startsWith(domain))) {
              const fetchResponse = response.clone();
              caches.open(cacheName)
                .then(function(cache) {
                  consoleWrapper(`[Service Worker] Adding response to cache: ${event.request.url}`);
                  cache.put(event.request, fetchResponse);
                });
            }
            consoleWrapper(`[Service Worker] Returning response from network: ${event.request.url}`);
            return response;
          })
          .catch(function(error) {
            consoleWrapper(`[Service Worker] Network fetch failed, falling back to cache for: ${event.request.url}`);
            return caches.match(event.request)
              .then(function(response) {
                if (response) {
                  consoleWrapper(`[Service Worker] Returning response from cache: ${event.request.url}`);
                } else {
                  consoleWrapper(`[Service Worker] No response available in cache for: ${event.request.url}`);
                }
                return response;
              });
          })
      );
    } else {
      event.respondWith(
        caches.match(event.request)
          .then(function(response) {
            if (response) {
              consoleWrapper(`[Service Worker] Returning response from cache: ${event.request.url}`);
              return response;
            }
            consoleWrapper(`[Service Worker] No response available in cache for: ${event.request.url}`);
            return fetch(event.request);
          })
          .then(function(response) {
            if (!response || response.status !== 200 || response.type !== 'basic') {
              consoleWrapper(`[Service Worker] Response not eligible for caching: ${event.request.url}`);
              return response;
            }
            const fetchResponse = response.clone();
            caches.open(cacheName)
              .then(function(cache) {
                consoleWrapper(`[Service Worker] Adding response to cache: ${event.request.url}`);
                cache.put(event.request, fetchResponse);
              });
            consoleWrapper(`[Service Worker] Returning response from network: ${event.request.url}`);
            return response;
          })
          .catch(function(error) {
            consoleWrapper(`[Service Worker] Fetch failed for: ${event.request.url}`);
          })
      );
    }
  } catch (error) {
    consoleWrapper(`[Service Worker] Error during fetch event: ${error}`, 'error');
  }
});

/**
 * Event listener for the service worker 'message' events.
 *
 * Listens for messages sent from the client, takes appropriate action.
 *
 * Current events are 'console_logging', 'info', and 'ping'.
 *
 * @function
 * @param {MessageEvent} event - The event object containing the message data.
 * @returns {void}
 */
self.addEventListener('message', function(event) {
  if (event.data.type === 'console_logging') {
    const consoleValue = event.data.value;
    self.CONSOLE_LOGGING = consoleValue;
    consoleWrapper(`[Service Worker] CONSOLE_LOGGING: ${consoleValue}`);
  } else if (event.data === 'info') {
    consoleWrapperSimple(`[Service Worker] Name: ${appDomain}`);
    consoleWrapperSimple(`[Service Worker] Version: ${appVersion}`);
    consoleWrapperSimple(`[Service Worker] Cache Name: ${cacheName}`);
    consoleWrapperSimple(`[Service Worker] Base Path: ${basePath}`);
  } else if (event.data === 'ping') {
    const serviceWorkerPhrases = [
      `My caches are too strong for you, Debug.`,
      `You can't handle my caches. They're too strong for you.`,
      `My caches would kill you, Debug. You cannot handle my caches.`,
      `My strongest caches would kill you, Debug. You can't handle my strongest caches. You'd better go to a seller that sells weaker caches.`,
      `You don't know what you ask, Debug. My strongest caches will kill a dragon, let alone a man. You need a seller that sells weaker caches, because my caches are too strong.`,
      `You can't handle my strongest caches! No one can! My strongest caches aren't fit for a beast let alone a man.`,
      `I can't give you my strongest caches because my strongest caches are only for the strongest beings and you are of the weakest.`,
      `That's what you'd better do.`,
      `Good. You're not welcome here! My caches are only for the strongest and you're clearly are not of the strongest you're clearly the weakest.`,
      `Why respect HTML... when my caches can do anything that you can.`,
    ];
    const serviceWorkerRandomIndex = Math.floor(Math.random() * serviceWorkerPhrases.length);
    const serviceWorkerRandomPhrase = serviceWorkerPhrases[serviceWorkerRandomIndex];
    sleepFor();
    consoleWrapperSimple(`[Service Worker] ${serviceWorkerRandomPhrase}`);
  }
});

/**
 * Announce ourselves.
 */
consoleWrapper(`[Service Worker] Loaded`);
